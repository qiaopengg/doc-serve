# 文档服务接口

## 1. 完整 DOCX 块流式推送 ⭐ 推荐

**GET** `/api/v1/docs/stream-docx`

### 说明
按段落切分文档，每个块都是完整的 DOCX 文件（累积式），支持边收边写、打字机效果。

### 请求
```
GET http://127.0.0.1:3000/api/v1/docs/stream-docx
```

### 响应头
```
Content-Type: application/x-wps-docx-chunks
X-WPS-Stream-Mode: docx-chunks
X-WPS-Delay-Ms: 150
```

### 响应体（分帧协议）
```
[4字节长度(大端)][完整docx1]
[4字节长度(大端)][完整docx2]
...
[4字节0]  // 结束标记
```

### 前端示例
```js
async function streamDocxChunks(url, { onDocx } = {}) {
  const res = await fetch(url)
  const reader = res.body.getReader()
  let buf = new Uint8Array(0)

  const concat = (a, b) => {
    const out = new Uint8Array(a.length + b.length)
    out.set(a, 0)
    out.set(b, a.length)
    return out
  }

  const readU32BE = (u8, off) =>
    (u8[off] << 24) | (u8[off + 1] << 16) | (u8[off + 2] << 8) | u8[off + 3]

  while (true) {
    const { done, value } = await reader.read()
    if (done) break
    buf = concat(buf, value)

    while (buf.length >= 4) {
      const len = readU32BE(buf, 0) >>> 0
      if (len === 0) return // 结束
      if (buf.length < 4 + len) break

      const docxBuffer = buf.slice(4, 4 + len)
      buf = buf.slice(4 + len)
      await onDocx?.(docxBuffer)
    }
  }
}

// 使用
await streamDocxChunks('http://127.0.0.1:3000/api/v1/docs/stream-docx', {
  onDocx: async (docxBuffer) => {
    await writeToWPS(docxBuffer) // 写入 WPS
  }
})
```

---

## 2. 二进制分片流式推送

**GET** `/api/v1/docs/stream`

### 响应头
```
Content-Type: application/x-wps-framed-chunks
X-WPS-Stream-Mode: framed-chunks
X-WPS-Filename: text.docx
X-WPS-Chunk-Size: 1024
X-WPS-Delay-Ms: 150
```

### 响应体
```
[4字节长度][二进制片段1]
[4字节长度][二进制片段2]
...
[4字节0]
```

---

## 3. 预览增量帧流

**GET** `/api/v1/docs/frames`

### 响应头
```
Content-Type: application/x-ndjson; charset=utf-8
X-WPS-Stream-Mode: ndjson-frames
X-WPS-Delay-Ms: 150
```

### 响应体（NDJSON）
每行一个 JSON 对象：
```json
{"docId":"test.docx","seq":1,"type":"preview.runs","ts":1700000000000,"payload":{"runs":[...]}}
{"docId":"test.docx","seq":2,"type":"preview.runs","ts":1700000000100,"payload":{"runs":[...]}}
{"docId":"test.docx","seq":3,"type":"final.docx.url","ts":1700000000200,"payload":{"url":"..."}}
{"docId":"test.docx","seq":4,"type":"control.done","ts":1700000000300,"payload":{"reason":"completed"}}
```

### 帧类型
- `preview.runs` - 预览内容（增量）
- `final.docx.url` - 最终 DOCX 下载地址
- `control.done` - 完成信号
- `control.error` - 错误信号

---

## 4. 最终 DOCX 下载

**GET** `/api/v1/docs/download`

### 响应头
```
Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document
Content-Disposition: attachment; filename*=UTF-8''test.docx
```

### 响应体
完整的 DOCX 文件（二进制）

---

## 错误响应

所有错误返回 JSON 格式：

```json
// 404 - 文档不存在
{ "error": "document_not_found" }

// 400 - 无效参数
{ "error": "invalid_doc_id" }

// 500 - 内部错误
{ "error": "internal_error" }
```

---

## 接口对比

| 接口 | 用途 | 推荐 |
|------|------|------|
| `/stream-docx` | 完整 DOCX 块流式推送 | ✅ 推荐 |
| `/stream` | 二进制分片推送 | ⚠️ 旧接口 |
| `/frames` | 预览增量帧流 | ✅ 双通道方案 |
| `/download` | 最终 DOCX 下载 | ✅ 配合 frames 使用 |
