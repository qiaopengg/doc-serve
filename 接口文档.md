# 文档服务接口（前端）

## 1) text.doc 二进制分片流式推送（旧接口）

**GET** `http://127.0.0.1:3000/api/v1/docs/stream`

跨域：
- 默认允许跨域（`Access-Control-Allow-Origin: *`）

说明：
- 只有一个接口，无任何 query 参数
- 每次请求会随机选择一个间隔 `delayMs`（100~200ms），后续每个数据块按该固定间隔依次推送

Response（关键）：
- `Content-Type: application/x-wps-framed-chunks`
- `X-WPS-Stream-Mode: framed-chunks`
- `X-WPS-Filename: <实际文件名>`
- `X-WPS-Chunk-Size: 1024`
- `X-WPS-Delay-Ms: <delayMs>`（每次请求固定一个值，范围 100~200）

Body（帧格式）：
- 重复：`[4字节长度(大端)] + [payload 二进制]`
- 结束：长度为 `0` 的 4 字节帧

## 2) 双通道：预览增量帧流 + 最终保真 docx（新接口）

用途：
- 预览增量帧流用于“边生成边写入 WPS”（逐字效果）
- 最终 docx 用于“生成结束后替换预览内容，保证 100% 保真”

### 2.1 预览增量帧流（Preview Stream）

说明：
- 新接口当前固定使用服务端 `test.docx` 作为资源

**GET** `http://127.0.0.1:3000/api/v1/docs/frames`
（兼容）**GET** `http://127.0.0.1:3000/docs/frames`

Response（关键）：
- `Content-Type: application/x-ndjson; charset=utf-8`
- `X-WPS-Stream-Mode: ndjson-frames`
- `X-WPS-Delay-Ms: <delayMs>`（每次请求固定一个值，范围 100~200）

Body（NDJSON，每行一个 JSON 帧）：

```json
{
  "docId": "string",
  "seq": 1,
  "type": "preview.runs | preview.text | preview.ops | final.docx.url | final.docx.binary | control.done | control.error | control.heartbeat",
  "ts": 1700000000000,
  "payload": {}
}
```

约束：
- `seq` 从 1 开始严格递增
- 客户端可用 `docId + seq` 做幂等去重

MVP 帧序列：
- 多个 `preview.runs`（增量预览）
- 一个 `final.docx.url`（最终 docx 下载地址）
- 一个 `control.done`（结束信号）
- 异常时：最后一帧为 `control.error`

### 2.2 最终 docx 下载（Final Docx）

**GET** `http://127.0.0.1:3000/api/v1/docs/download`
（兼容）**GET** `http://127.0.0.1:3000/docs/download`

Response：
- `Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document`（或 doc/docx 对应类型）
- `Content-Disposition: attachment; filename*=UTF-8''...`

## 前端流式读取示例（打字机式分发）

```js
async function streamFramedChunks(url, { onPiece, pieceSize = 512, delayMs = 10 } = {}) {
  const res = await fetch(url)
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  const reader = res.body.getReader()
  let buf = new Uint8Array(0)

  const concat = (a, b) => {
    const out = new Uint8Array(a.length + b.length)
    out.set(a, 0)
    out.set(b, a.length)
    return out
  }

  const readU32BE = (u8, off) =>
    (u8[off] << 24) | (u8[off + 1] << 16) | (u8[off + 2] << 8) | u8[off + 3]

  while (true) {
    const { done, value } = await reader.read()
    if (done) break
    buf = concat(buf, value)

    while (buf.length >= 4) {
      const len = readU32BE(buf, 0) >>> 0
      if (len === 0) return
      if (buf.length < 4 + len) break

      const payload = buf.slice(4, 4 + len)
      buf = buf.slice(4 + len)

      for (let i = 0; i < payload.length; i += pieceSize) {
        const piece = payload.slice(i, Math.min(i + pieceSize, payload.length))
        await onPiece?.(piece)
        if (delayMs) await new Promise((r) => setTimeout(r, delayMs))
      }
    }
  }
}
```

## 错误响应（JSON）

- 404：`{ "error": "document_not_found" }`
```json
{ "error": "document_not_found" }
```
- 400：`{ "error": "invalid_doc_id" }`
```json
{ "error": "invalid_doc_id" }
```
- 500：`{ "error": "internal_error" }`
```json
{ "error": "internal_error" }
```
